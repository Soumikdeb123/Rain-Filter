<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#D4B896">
    <title>Rain Camera - Android</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            font-family: 'Roboto', sans-serif;
            position: fixed;
        }

        #videoContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #rainCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        #permissionScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #D4B896 0%, #1C1C1C 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            color: white;
            text-align: center;
            padding: 20px;
        }

        #permissionScreen.hidden {
            display: none;
        }

        .icon {
            font-size: 72px;
            margin-bottom: 24px;
        }

        h1 {
            font-size: 28px;
            font-weight: 500;
            margin-bottom: 12px;
            letter-spacing: 0.5px;
        }

        p {
            font-size: 16px;
            opacity: 0.95;
            margin-bottom: 36px;
            max-width: 320px;
            line-height: 1.5;
        }

        #startButton {
            background: white;
            color: #1C1C1C;
            border: none;
            padding: 16px 48px;
            font-size: 16px;
            font-weight: 500;
            border-radius: 28px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 20px rgba(0,0,0,0.25);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #startButton:active {
            transform: scale(0.96);
        }

        #errorMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.92);
            color: white;
            padding: 24px 32px;
            border-radius: 8px;
            z-index: 100;
            display: none;
            text-align: center;
            max-width: 90%;
            font-size: 15px;
            line-height: 1.6;
        }

        #caption {
            position: fixed;
            bottom: 48px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            text-shadow: 0 2px 12px rgba(0,0,0,0.7);
            z-index: 3;
            opacity: 0.9;
            text-align: center;
            padding: 0 20px;
        }

        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 42px;
            height: 42px;
            animation: spin 0.8s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .platform-badge {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.25);
            backdrop-filter: blur(10px);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            z-index: 11;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <!-- Platform Badge -->
    <div class="platform-badge">Android</div>

    <!-- Permission Screen -->
    <div id="permissionScreen">
        <div class="icon" style="font-size: 80px; font-family: serif; font-weight: 300; letter-spacing: 3px; line-height: 1;">
            <div style="font-size: 48px; margin-bottom: 10px;">â™ž</div>
            <div style="font-size: 20px; font-weight: 500; letter-spacing: 4px;">BURBERRY</div>
        </div>
        <h1>Let's Get Drenched in Burberry</h1>
        <p>Tap below to allow camera access and begin</p>
        <button id="startButton">Start</button>
    </div>

    <!-- Camera Feed -->
    <div id="videoContainer">
        <video id="video" playsinline autoplay muted></video>
    </div>

    <!-- Rain Overlay Canvas -->
    <canvas id="rainCanvas"></canvas>

    <!-- Subtle Rain Audio -->
    <audio id="rainAudio" loop>
        <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=" type="audio/wav">
    </audio>

    <!-- Optional Caption -->
    <div id="caption" style="display: none;">
        <!-- Add your text here if needed -->
    </div>

    <!-- Error Message -->
    <div id="errorMessage"></div>

    <script>
        class RainAudio {
            constructor() {
                this.audioContext = null;
                this.rainNode = null;
                this.gainNode = null;
                this.dropGainNode = null;
                this.isPlaying = false;
                this.dropInterval = null;
            }

            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Background rain ambience
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = 0.12;
                    this.gainNode.connect(this.audioContext.destination);
                    
                    // Raindrop sounds
                    this.dropGainNode = this.audioContext.createGain();
                    this.dropGainNode.gain.value = 0.2; // Louder droplets (was 0.08)
                    this.dropGainNode.connect(this.audioContext.destination);
                    
                    this.createRainSound();
                } catch (error) {
                    console.log('Audio not supported:', error);
                }
            }

            createRainSound() {
                // Background rain ambience
                const bufferSize = this.audioContext.sampleRate * 2;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.3;
                }
                
                for (let i = 1; i < bufferSize; i++) {
                    data[i] = data[i] * 0.5 + data[i - 1] * 0.5;
                }
                
                this.rainNode = this.audioContext.createBufferSource();
                this.rainNode.buffer = buffer;
                this.rainNode.loop = true;
                
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1500;
                
                this.rainNode.connect(filter);
                filter.connect(this.gainNode);
            }

            createRaindrop() {
                // Create soft natural water droplet sound (no metallic plinks)
                const dropDuration = 0.15; // Longer for softer sound
                const sampleRate = this.audioContext.sampleRate;
                const dropBuffer = this.audioContext.createBuffer(1, sampleRate * dropDuration, sampleRate);
                const dropData = dropBuffer.getChannelData(0);
                
                // Generate soft water droplet sound
                for (let i = 0; i < dropData.length; i++) {
                    const t = i / sampleRate;
                    const envelope = Math.exp(-t * 25); // Slower, softer decay
                    
                    // Soft low frequency "thump" (water hitting surface)
                    const lowFreq = 150 + Math.random() * 150; // Lower frequencies only (150-300Hz)
                    const low = Math.sin(2 * Math.PI * lowFreq * t) * 0.5;
                    
                    // Mid-low "splash" body
                    const midFreq = 300 + Math.random() * 200; // 300-500Hz
                    const mid = Math.sin(2 * Math.PI * midFreq * t) * 0.3;
                    
                    // Very soft texture (not sharp noise)
                    const softNoise = (Math.random() * 2 - 1) * 0.08 * envelope;
                    
                    // Combine for soft water sound
                    dropData[i] = (low + mid + softNoise) * envelope * 0.7;
                }
                
                const dropSource = this.audioContext.createBufferSource();
                dropSource.buffer = dropBuffer;
                
                // Add low-pass filter to remove any harshness
                const softFilter = this.audioContext.createBiquadFilter();
                softFilter.type = 'lowpass';
                softFilter.frequency.value = 600; // Cut all high frequencies
                
                // Random volume variation
                const dropGain = this.audioContext.createGain();
                dropGain.gain.value = 0.5 + Math.random() * 0.3; // Softer overall
                
                // Random panning for spatial effect
                const panner = this.audioContext.createStereoPanner();
                panner.pan.value = Math.random() * 2 - 1;
                
                dropSource.connect(softFilter);
                softFilter.connect(dropGain);
                dropGain.connect(panner);
                panner.connect(this.dropGainNode);
                dropSource.start(0);
            }

            startDropSounds() {
                // Play random raindrop sounds more frequently
                this.dropInterval = setInterval(() => {
                    if (Math.random() > 0.15) { // 85% chance each interval
                        this.createRaindrop();
                    }
                }, 50 + Math.random() * 90); // Faster interval 50-140ms
            }
            }

            play() {
                if (!this.isPlaying && this.rainNode && this.audioContext) {
                    try {
                        this.audioContext.resume();
                        this.rainNode.start(0);
                        this.isPlaying = true;
                        
                        // Fade in background rain
                        this.gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                        this.gainNode.gain.linearRampToValueAtTime(0.12, this.audioContext.currentTime + 2);
                        
                        // Start raindrop sounds after 1 second
                        setTimeout(() => {
                            this.startDropSounds();
                        }, 1000);
                    } catch (error) {
                        console.log('Audio play error:', error);
                    }
                }
            }

            stop() {
                if (this.isPlaying && this.rainNode) {
                    try {
                        this.rainNode.stop();
                        this.isPlaying = false;
                        if (this.dropInterval) {
                            clearInterval(this.dropInterval);
                        }
                    } catch (error) {
                        console.log('Audio stop error:', error);
                    }
                }
            }
        }

        class RainEffect {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d', { alpha: true });
                this.drops = [];
                this.maxDrops = 250; // More drops for realistic rain
                this.init();
            }

            init() {
                this.resize();
                window.addEventListener('resize', () => this.resize());
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => this.resize(), 100);
                });
                this.createDrops();
                this.animate();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            createDrops() {
                this.drops = [];
                for (let i = 0; i < this.maxDrops; i++) {
                    this.drops.push(this.createDrop());
                }
            }

            createDrop() {
                return {
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height - this.canvas.height,
                    length: Math.random() * 35 + 25,
                    speed: Math.random() * 10 + 7,
                    opacity: Math.random() * 0.45 + 0.3,
                    width: Math.random() * 3.5 + 2.5,
                    blur: Math.random() * 2.5 + 1
                };
            }

            update() {
                for (let drop of this.drops) {
                    drop.y += drop.speed; // Only move down, no horizontal movement
                    
                    if (drop.y > this.canvas.height) {
                        drop.y = -drop.length;
                        drop.x = Math.random() * this.canvas.width;
                    }
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (let drop of this.drops) {
                    // More natural, less "perfect" droplets
                    const centerX = drop.x;
                    const topY = drop.y;
                    const bottomY = drop.y + drop.length;
                    const width = drop.width;
                    
                    // Add motion blur effect
                    this.ctx.shadowBlur = drop.blur;
                    this.ctx.shadowColor = `rgba(255, 255, 255, ${drop.opacity * 0.3})`;
                    
                    // Simple realistic gradient - lighter at top, darker at bottom
                    const gradient = this.ctx.createLinearGradient(
                        centerX, topY, centerX, bottomY
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${drop.opacity * 0.9})`);
                    gradient.addColorStop(0.6, `rgba(230, 240, 255, ${drop.opacity * 0.7})`);
                    gradient.addColorStop(1, `rgba(200, 220, 245, ${drop.opacity * 0.3})`);
                    
                    // Draw natural elongated droplet shape
                    this.ctx.beginPath();
                    this.ctx.fillStyle = gradient;
                    
                    // Top rounded
                    this.ctx.arc(centerX, topY + width/2, width/2, Math.PI, 0);
                    // Sides
                    this.ctx.lineTo(centerX + width/2, bottomY - width/3);
                    // Bottom tapered point (more natural)
                    this.ctx.quadraticCurveTo(centerX + width/2, bottomY, centerX, bottomY);
                    this.ctx.quadraticCurveTo(centerX - width/2, bottomY, centerX - width/2, bottomY - width/3);
                    // Close
                    this.ctx.lineTo(centerX - width/2, topY + width/2);
                    this.ctx.fill();
                    
                    // Quick highlight - not perfect, more natural
                    this.ctx.shadowBlur = 0;
                    this.ctx.beginPath();
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${drop.opacity * 0.6})`;
                    this.ctx.ellipse(centerX - width/4, topY + width, width/3, width/2, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Reset shadow
                this.ctx.shadowBlur = 0;
            }

            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        class CameraApp {
            constructor() {
                this.video = document.getElementById('video');
                this.permissionScreen = document.getElementById('permissionScreen');
                this.startButton = document.getElementById('startButton');
                this.errorMessage = document.getElementById('errorMessage');
                this.rainEffect = null;
                this.rainAudio = null;
                this.stream = null;

                this.startButton.addEventListener('click', () => this.requestCamera());
                
                // Handle page visibility
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && this.stream) {
                        this.video.pause();
                    } else if (!document.hidden && this.stream) {
                        this.video.play().catch(e => console.log('Resume play error:', e));
                    }
                });

                // Prevent screen from sleeping (Android)
                this.wakeLock = null;
                this.requestWakeLock();
            }

            async requestWakeLock() {
                try {
                    if ('wakeLock' in navigator) {
                        this.wakeLock = await navigator.wakeLock.request('screen');
                        console.log('Wake Lock active');
                    }
                } catch (err) {
                    console.log('Wake Lock error:', err);
                }
            }

            async requestCamera() {
                this.startButton.innerHTML = '<div class="spinner"></div>';
                this.startButton.disabled = true;

                try {
                    // Android Chrome optimized constraints
                    const constraints = {
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1920 },
                            height: { ideal: 1080 },
                            frameRate: { ideal: 30 }
                        },
                        audio: false
                    };

                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.stream;
                    
                    this.video.onloadedmetadata = () => {
                        this.video.play().then(() => {
                            this.permissionScreen.classList.add('hidden');
                            
                            if (!this.rainEffect) {
                                this.rainEffect = new RainEffect(document.getElementById('rainCanvas'));
                            }
                            
                            // Start subtle rain audio
                            if (!this.rainAudio) {
                                this.rainAudio = new RainAudio();
                                this.rainAudio.init();
                                this.rainAudio.play();
                            }
                        }).catch(error => {
                            console.error('Video play error:', error);
                            this.showError('Unable to start camera. Please try again.');
                            this.startButton.innerHTML = 'Try Again';
                            this.startButton.disabled = false;
                        });
                    };

                } catch (error) {
                    console.error('Camera access error:', error);
                    this.showError(this.getErrorMessage(error));
                    this.startButton.innerHTML = 'Try Again';
                    this.startButton.disabled = false;
                }
            }

            getErrorMessage(error) {
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    return 'Camera access denied.\n\nPlease allow camera permission when prompted, or check your browser settings.';
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    return 'No camera found on this device.';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    return 'Camera is already in use.\n\nPlease close other apps using the camera and try again.';
                } else if (error.name === 'SecurityError') {
                    return 'Camera blocked for security reasons.\n\nPlease ensure you\'re using HTTPS.';
                } else {
                    return 'Unable to access camera.\n\nPlease check your permissions and try again.';
                }
            }

            showError(message) {
                this.errorMessage.textContent = message;
                this.errorMessage.style.display = 'block';
                setTimeout(() => {
                    this.errorMessage.style.display = 'none';
                }, 6000);
            }
        }

        // Initialize app
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => new CameraApp());
        } else {
            new CameraApp();
        }

        // Lock screen orientation to portrait (optional)
        if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('portrait').catch(err => {
                console.log('Orientation lock not supported:', err);
            });
        }
    </script>
</body>
</html>
