<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <title>Rain Camera - iOS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            position: fixed;
        }

        #videoContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        #rainCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        #permissionScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #D4B896 0%, #1C1C1C 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            color: white;
            text-align: center;
            padding: 20px;
        }

        #permissionScreen.hidden {
            display: none;
        }

        .icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 28px;
            font-weight: 600;
            margin-bottom: 12px;
            letter-spacing: -0.5px;
        }

        p {
            font-size: 17px;
            opacity: 0.9;
            margin-bottom: 30px;
            max-width: 300px;
            line-height: 1.4;
        }

        #startButton {
            background: white;
            color: #1C1C1C;
            border: none;
            padding: 16px 48px;
            font-size: 18px;
            font-weight: 600;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            -webkit-appearance: none;
        }

        #startButton:active {
            transform: scale(0.95);
        }

        #errorMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 24px 32px;
            border-radius: 12px;
            z-index: 100;
            display: none;
            text-align: center;
            max-width: 85%;
            font-size: 16px;
            line-height: 1.5;
        }

        #caption {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 15px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.7);
            z-index: 3;
            opacity: 0.85;
            text-align: center;
            padding: 0 20px;
        }

        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .platform-badge {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
            z-index: 11;
        }
    </style>
</head>
<body>
    <!-- Platform Badge -->
    <div class="platform-badge">iOS</div>

    <!-- Permission Screen -->
    <div id="permissionScreen">
        <div class="icon" style="font-size: 80px; font-family: serif; font-weight: 300; letter-spacing: 3px; line-height: 1;">
            <div style="font-size: 48px; margin-bottom: 10px;">â™ž</div>
            <div style="font-size: 20px; font-weight: 500; letter-spacing: 4px;">BURBERRY</div>
        </div>
        <h1>Let's Get Drenched in Burberry</h1>
        <p>Allow camera access to begin your journey</p>
        <button id="startButton">Start Experience</button>
    </div>

    <!-- Camera Feed -->
    <div id="videoContainer">
        <video id="video" playsinline autoplay muted webkit-playsinline></video>
    </div>

    <!-- Rain Overlay Canvas -->
    <canvas id="rainCanvas"></canvas>

    <!-- Subtle Rain Audio -->
    <audio id="rainAudio" loop>
        <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=" type="audio/wav">
    </audio>

    <!-- Optional Caption -->
    <div id="caption" style="display: none;">
        <!-- Add your text here if needed -->
    </div>

    <!-- Error Message -->
    <div id="errorMessage"></div>

    <script>
        class RainAudio {
            constructor() {
                this.audioContext = null;
                this.rainNode = null;
                this.gainNode = null;
                this.dropGainNode = null;
                this.isPlaying = false;
                this.dropInterval = null;
            }

            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Background rain ambience
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = 0.12;
                    this.gainNode.connect(this.audioContext.destination);
                    
                    // Raindrop sounds
                    this.dropGainNode = this.audioContext.createGain();
                    this.dropGainNode.gain.value = 0.18; // Louder droplets
                    this.dropGainNode.connect(this.audioContext.destination);
                    
                    this.createRainSound();
                } catch (error) {
                    console.log('Audio not supported:', error);
                }
            }

            createRainSound() {
                // Background rain ambience
                const bufferSize = this.audioContext.sampleRate * 2;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.3;
                }
                
                for (let i = 1; i < bufferSize; i++) {
                    data[i] = data[i] * 0.5 + data[i - 1] * 0.5;
                }
                
                this.rainNode = this.audioContext.createBufferSource();
                this.rainNode.buffer = buffer;
                this.rainNode.loop = true;
                
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1500;
                
                this.rainNode.connect(filter);
                filter.connect(this.gainNode);
            }

            createRaindrop() {
                // Create soft natural water droplet sound (no metallic plinks)
                const dropDuration = 0.15; // Longer for softer sound
                const sampleRate = this.audioContext.sampleRate;
                const dropBuffer = this.audioContext.createBuffer(1, sampleRate * dropDuration, sampleRate);
                const dropData = dropBuffer.getChannelData(0);
                
                // Generate soft water droplet sound
                for (let i = 0; i < dropData.length; i++) {
                    const t = i / sampleRate;
                    const envelope = Math.exp(-t * 25); // Slower, softer decay
                    
                    // Soft low frequency "thump" (water hitting surface)
                    const lowFreq = 150 + Math.random() * 150; // Lower frequencies only (150-300Hz)
                    const low = Math.sin(2 * Math.PI * lowFreq * t) * 0.5;
                    
                    // Mid-low "splash" body
                    const midFreq = 300 + Math.random() * 200; // 300-500Hz
                    const mid = Math.sin(2 * Math.PI * midFreq * t) * 0.3;
                    
                    // Very soft texture (not sharp noise)
                    const softNoise = (Math.random() * 2 - 1) * 0.08 * envelope;
                    
                    // Combine for soft water sound
                    dropData[i] = (low + mid + softNoise) * envelope * 0.7;
                }
                
                const dropSource = this.audioContext.createBufferSource();
                dropSource.buffer = dropBuffer;
                
                // Add low-pass filter to remove any harshness
                const softFilter = this.audioContext.createBiquadFilter();
                softFilter.type = 'lowpass';
                softFilter.frequency.value = 600; // Cut all high frequencies
                
                // Random volume variation
                const dropGain = this.audioContext.createGain();
                dropGain.gain.value = 0.5 + Math.random() * 0.3; // Softer overall
                
                // Random panning for spatial effect
                const panner = this.audioContext.createStereoPanner();
                panner.pan.value = Math.random() * 2 - 1;
                
                dropSource.connect(softFilter);
                softFilter.connect(dropGain);
                dropGain.connect(panner);
                panner.connect(this.dropGainNode);
                dropSource.start(0);
            }

            startDropSounds() {
                // Play random raindrop sounds more frequently
                this.dropInterval = setInterval(() => {
                    if (Math.random() > 0.2) { // 80% chance each interval (was 70%)
                        this.createRaindrop();
                    }
                }, 60 + Math.random() * 100); // Faster interval 60-160ms (was 80-200ms)
            }

            play() {
                if (!this.isPlaying && this.rainNode && this.audioContext) {
                    try {
                        this.audioContext.resume();
                        this.rainNode.start(0);
                        this.isPlaying = true;
                        
                        // Fade in background rain
                        this.gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                        this.gainNode.gain.linearRampToValueAtTime(0.12, this.audioContext.currentTime + 2);
                        
                        // Start raindrop sounds after 1 second
                        setTimeout(() => {
                            this.startDropSounds();
                        }, 1000);
                    } catch (error) {
                        console.log('Audio play error:', error);
                    }
                }
            }

            stop() {
                if (this.isPlaying && this.rainNode) {
                    try {
                        this.rainNode.stop();
                        this.isPlaying = false;
                        if (this.dropInterval) {
                            clearInterval(this.dropInterval);
                        }
                    } catch (error) {
                        console.log('Audio stop error:', error);
                    }
                }
            }
        }

        class RainEffect {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.drops = [];
                this.maxDrops = 200; // More drops for realistic rain
                this.init();
            }

            init() {
                this.resize();
                window.addEventListener('resize', () => this.resize());
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => this.resize(), 100);
                });
                this.createDrops();
                this.animate();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            createDrops() {
                this.drops = [];
                for (let i = 0; i < this.maxDrops; i++) {
                    this.drops.push(this.createDrop());
                }
            }

            createDrop() {
                return {
                    x: Math.random() * (this.canvas.width + 200) - 100, // Start wider for diagonal
                    y: Math.random() * this.canvas.height - this.canvas.height,
                    length: Math.random() * 30 + 20,
                    speed: Math.random() * 8 + 6,
                    opacity: Math.random() * 0.4 + 0.25,
                    width: Math.random() * 3 + 2.5,
                    blur: Math.random() * 2 + 1,
                    windOffset: Math.random() * 3 + 2 // Stronger diagonal wind (was 1-3)
                };
            }

            update() {
                for (let drop of this.drops) {
                    drop.y += drop.speed;
                    drop.x += drop.windOffset; // Move diagonally
                    
                    if (drop.y > this.canvas.height || drop.x > this.canvas.width) {
                        drop.y = -drop.length;
                        drop.x = Math.random() * this.canvas.width;
                    }
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (let drop of this.drops) {
                    // More natural, less "perfect" droplets
                    const centerX = drop.x;
                    const topY = drop.y;
                    const bottomY = drop.y + drop.length;
                    const width = drop.width;
                    
                    // Add motion blur effect
                    this.ctx.shadowBlur = drop.blur;
                    this.ctx.shadowColor = `rgba(255, 255, 255, ${drop.opacity * 0.3})`;
                    
                    // Simple realistic gradient - lighter at top, darker at bottom
                    const gradient = this.ctx.createLinearGradient(
                        centerX, topY, centerX, bottomY
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${drop.opacity * 0.9})`);
                    gradient.addColorStop(0.6, `rgba(230, 240, 255, ${drop.opacity * 0.7})`);
                    gradient.addColorStop(1, `rgba(200, 220, 245, ${drop.opacity * 0.3})`);
                    
                    // Draw natural elongated droplet shape
                    this.ctx.beginPath();
                    this.ctx.fillStyle = gradient;
                    
                    // Top rounded
                    this.ctx.arc(centerX, topY + width/2, width/2, Math.PI, 0);
                    // Sides
                    this.ctx.lineTo(centerX + width/2, bottomY - width/3);
                    // Bottom tapered point (more natural)
                    this.ctx.quadraticCurveTo(centerX + width/2, bottomY, centerX, bottomY);
                    this.ctx.quadraticCurveTo(centerX - width/2, bottomY, centerX - width/2, bottomY - width/3);
                    // Close
                    this.ctx.lineTo(centerX - width/2, topY + width/2);
                    this.ctx.fill();
                    
                    // Quick highlight - not perfect, more natural
                    this.ctx.shadowBlur = 0;
                    this.ctx.beginPath();
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${drop.opacity * 0.6})`;
                    this.ctx.ellipse(centerX - width/4, topY + width, width/3, width/2, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Reset shadow
                this.ctx.shadowBlur = 0;
            }

            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        class CameraApp {
            constructor() {
                this.video = document.getElementById('video');
                this.permissionScreen = document.getElementById('permissionScreen');
                this.startButton = document.getElementById('startButton');
                this.errorMessage = document.getElementById('errorMessage');
                this.rainEffect = null;
                this.rainAudio = null;
                this.stream = null;

                this.startButton.addEventListener('click', () => this.requestCamera());
                
                // Handle page visibility for iOS
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && this.stream) {
                        // Pause when tab is hidden
                        this.video.pause();
                    } else if (!document.hidden && this.stream) {
                        // Resume when tab is visible
                        this.video.play();
                    }
                });
            }

            async requestCamera() {
                this.startButton.innerHTML = '<div class="spinner"></div>';
                this.startButton.disabled = true;

                try {
                    // iOS Safari optimized constraints
                    const constraints = {
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        },
                        audio: false
                    };

                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.stream;
                    
                    // iOS requires explicit play() call
                    this.video.onloadedmetadata = () => {
                        this.video.play().then(() => {
                            this.permissionScreen.classList.add('hidden');
                            
                            if (!this.rainEffect) {
                                this.rainEffect = new RainEffect(document.getElementById('rainCanvas'));
                            }
                            
                            // Start subtle rain audio
                            if (!this.rainAudio) {
                                this.rainAudio = new RainAudio();
                                this.rainAudio.init();
                                this.rainAudio.play();
                            }
                        }).catch(error => {
                            console.error('Video play error:', error);
                            this.showError('Unable to start camera. Please tap to try again.');
                            this.startButton.innerHTML = 'Try Again';
                            this.startButton.disabled = false;
                        });
                    };

                } catch (error) {
                    console.error('Camera access error:', error);
                    this.showError(this.getErrorMessage(error));
                    this.startButton.innerHTML = 'Try Again';
                    this.startButton.disabled = false;
                }
            }

            getErrorMessage(error) {
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    return 'Camera access denied.\n\nPlease go to Settings > Safari > Camera and allow access.';
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    return 'No camera found on this device.';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    return 'Camera is already in use.\n\nPlease close other apps using the camera.';
                } else if (error.name === 'SecurityError') {
                    return 'Camera access blocked.\n\nPlease use HTTPS or enable camera in iOS settings.';
                } else {
                    return 'Unable to access camera.\n\nPlease try again or check your settings.';
                }
            }

            showError(message) {
                this.errorMessage.textContent = message;
                this.errorMessage.style.display = 'block';
                setTimeout(() => {
                    this.errorMessage.style.display = 'none';
                }, 6000);
            }
        }

        // Initialize app
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => new CameraApp());
        } else {
            new CameraApp();
        }

        // Prevent iOS bounce/scroll
        document.body.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
